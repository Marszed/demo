HelloWorld.vue -> vue-loader -> vue-template-compiler(script,style,template) -> AST -> generate
-> render (return VNode) -> update -> patch old VNode -> dif -> real Dom 

#### .vue文件到真实Dom整个流程

1. webpack构建时，匹配到.vue文件交由vue-loader进行代码转换预处理
``` json
const webpackConfig = {
  ....
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue',
      },
    ],
  },
}
```

2. vue-loader@^15.7.2
-. parse方法将source code交由`vue-template-loader@^2.6.10`处理(通过lru-cache做缓存，优化编译性能), 返回template、script、 styles
-. 其中会处理webpack vue rules.option各种指定loader(譬如: sass-loader、less-loader等)
``` javascript
const {
    source,
    filename = '',
    compiler,
    compilerParseOptions = { pad: 'line' } as VueTemplateCompilerParseOptions,
    sourceRoot = '',
    needMap = true
  } = options
  const cacheKey = hash(filename + source)
  let output: SFCDescriptor = cache.get(cacheKey)
  if (output) return output
  output = compiler.parseComponent(source, compilerParseOptions)
```
![vue-loader](https://github.com/Marszed/demo/blob/master/img/WechatIMG1.png)

3. Vue.prototype.$mount Api
- 执行mount时，若`render`方法不存在会将`template`进行`compileToFunctions`运行时编译得到`render`与`staticRenderFns`。`render`返回的是VNode节点供渲染以及update的时候进行patch
``` javascript
// 将不带编译的$mount方法缓存起来
const mount = Vue.prototype.$mount
// 重写Vue.prototype.$mount，添加模板编译
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  // 处理模板templete，编译成render函数，render不存在的时编译template，否则优先使用render
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
    // 获取element的outerHTML
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

     // 将template编译成render函数，这里会有render以及staticRenderFns两个返回，staticRenderFns是编译优化，static静态不需要在VNode更新时进行patch，优化性能
     
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

4. new Vue实例化this_init，初始化(props、data、lifeStyle、render等),$mount

``` javascript
Vue.prototype._init = function (options?: Object) {    const vm: Component = this
    // a uid
    vm._uid = uid++    let startTag, endTag    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-init:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }    // a flag to avoid this being observed
    /*一个防止vm实例自身被观察的标志位*/
    vm._isVue = true
    // merge options
    if (options && options._isComponent) {      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }    // expose real self
    vm._self = vm    /*初始化生命周期*/
    initLifecycle(vm)    /*初始化事件*/
    initEvents(vm)    /*初始化render*/
    initRender(vm)    /*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    /*初始化props、methods、data、computed与watch*/
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    /*调用created钩子函数并且触发created钩子事件*/
    callHook(vm, 'created')    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {      /*格式化组件名*/
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`${vm._name} init`, startTag, endTag)
    }    if (vm.$options.el) {      /*挂载组件*/
      vm.$mount(vm.$options.el)
    }
  }
```







