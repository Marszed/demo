### `译` CommonJs 1.0 [wiki](http://wiki.commonjs.org/wiki/Modules/1.0)

###### 该规范解决了如何编写模块以便在一类模块系统中可互操作，该模块系统可以是客户端和服务器端，安全或不安全，今天实现，或由具有语法扩展的未来系统支持。这些模块提供了它们的顶级范围的隐私，从其他模块导入单体对象的工具，以及输出它们自己的API。通过暗示，该规范定义了模块系统必须提供的最小特征，以便支持互操作的模块。

##### 模块上下文
1. 在一个模块中，有一个自由变量`require`，即一个函数。
  - `require`函数接受模块标识符。
  - `require`返回外部模块的导出API。
  - 如果存在依赖周期，则外部模块可能在它的一个传递依赖项所需的时间内完成执行；在这种情况下，由`require`返回的对象必须至少包含在调用导致当前模块执行的调用之前，外部模块已经准备好的输出。
  - 如果请求的模块不能返回，`require`必须抛出一个错误。
2. 在一个模块中，有一个称为`exports`的自由变量，这是模块可以在执行时添加API的对象。
3. 模块必须使用`exports`对象作为唯一的出口手段。

##### 标识符模块
1. 模块标识符是由前斜线限定的“术语”字符串。
2. 术语必须是CAMELCASE标识符`.`或`..`。
3. 模块标识符可能没有像`.js`这样的文件扩展名。
3. 模块标识符可以是`relative`或`top-level`。如果第一个词是`.`或`..`，则模块标识符是`relative`。
5. `Top-level`从概念模块名称空间根解析。
6. 相对标识符相对于写入和调用`require`的模块的标识符来解析。

##### 非明确规定
1. 模块是否存储有数据库、文件系统或工厂功能，或者与链接库互换。
2. 模块加载程序是否支持用于解析模块标识符的路径。

------------------------------

### `译` CommonJs 1.1 [wiki](http://wiki.commonjs.org/wiki/Modules/1.1)

###### 该规范解决了如何编写模块以便在一类模块系统中可互操作，该模块系统可以是客户端和服务器端，安全或不安全，今天实现，或由具有语法扩展的未来系统支持。这些模块提供了它们的顶级范围的隐私，从其他模块导入单体对象的工具，以及输出它们自己的API。通过暗示，该规范定义了模块系统必须提供的最小特征，以便支持互操作的模块。

##### 模块上下文
a. 在一个模块中，有一个自由变量`require`，即一个函数。
1. `require`函数接受模块标识符。
2. `require`返回外部模块的导出API。
3. 如果存在依赖周期，则外部模块可能在它的一个传递依赖项所需的时间内完成执行；在这种情况下，由`require`返回的对象必须至少包含在调用导致当前模块执行的调用之前，外部模块已经准备好的输出。
4. 如果请求的模块不能返回，`require`必须抛出一个错误。
5. `require`函数可能有一个`main`属性，它是只读的，不删除，并表示程序的顶层`module`对象。如果提供此属性，则必须与主程序的`module`对象引用相同。
6. `require`函数可以有一个`paths`属性，即路径字符串的优先级数组，从高到低，到顶级模块目录的路径。
- 在`sandbox`（安全模块系统）中不存在`paths`属性。
- `paths`属性必须在所有模块中引用相同。
- 用替代对象替换`paths`对象可能没有任何效果。
- 如果存在`paths`属性，就必须通过相应的模块搜索行为来反映`paths`内容的修改。
- 如果存在`paths`属性，则它可能不是搜索路径的穷尽列表，因为加载器可以在前面提到的路径之前或之后在内部查找其他位置。
- 如果存在`paths`属性，则是加载程序对所提供路径的解析、规范化或规范化。

b. 在一个模块中，有一个称为“导出”的自由变量，这是模块可以在执行时添加API的对象。
  - 模块必须使用“出口”对象作为唯一的出口手段。
  
c. 在一个模块中，必须有一个自由变量`module`，即一个对象。
-  `module`对象必须具有只读，不删除“ID”属性，该属性是模块的顶级“ID”。“ID”属性必须是这样的要求（模块ID）将返回导出对象，从中导出模块ID起源于。（也就是说，模块ID可以传递给另一个模块，并要求它必须返回原始模块）。
- `module`对象可能有一个“URI”字符串，它是创建模块所需资源的完全限定URI。“URI”属性不能存在于沙箱中。

#### 标识符模块
1. 模块标识符是由前斜线限定的“术语”字符串。
2. 术语必须是CAMELCASE标识符`.`或`..`。
3. 模块标识符可能没有像`.js`这样的文件扩展名。
3. 模块标识符可以是`relative`或`top-level`。如果第一个词是`.`或`..`，则模块标识符是`relative`。
5. `Top-level`从概念模块名称空间根解析。
6. 相对标识符相对于写入和调用`require`的模块的标识符来解析。

##### 非明确规定
1. 模块是否存储有数据库、文件系统或工厂功能，或者与链接库互换。
2. 模块加载程序是否支持用于解析模块标识符的路径。

------------------------------

### 概述: 
###### CommonJS是同步的，意味着你想调用模块里的方法，必须先用require加载模块。这对服务器端的Nodejs来说不是问题，因为模块的JS文件都在本地硬盘上，CPU的读取时间非常快。但如果是浏览器环境，要从服务器加载模块。模块的加载将取决于网速，如果采用同步，网络情绪不稳定时，页面可能卡住,这就必须采用异步模式。所以，就有了 AMD解决方案； 


